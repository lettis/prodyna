
#' Read dihedrals.
#'
#' Read the columns corresponding to the \eqn{\phi} and \eqn{\psi} angles of the
#' given residues.
#'
#' @param dihedrals Character, name of the .dih file containing the dihedral
#'  angles.
#' @param dihedralsInfo Character, name of the .dih.info file as generated by
#'  \code{\link{generate.dihedrals}}. If \code{NULL} the filename is assumed to
#'  be <dihedrals>.info
#' @param resnos Numeric vector, residue numbers for which dihedral angles
#'  should be read. If \code{NULL} (default) read dihedrals for all residues.
#' @return A data.frame with \eqn{\phi} and \eqn{\psi} angles.
#' @export
read.dihedrals <- function(dihedrals, dihedralsInfo=NULL, resnos=NULL) {

  # Assume default naming
  if (is.null(dihedralsInfo)) {
    dihedralsInfo <- paste(dihedrals, ".info", sep="")
  }

  dInf <- read.dihedrals.info(dihedralsInfo)
  storedResnos <- (1:dInf$nRes)[-dInf$skippedResnos]

  if (is.null(resnos)){
    # Read all dihedrals.
    dih <- data.table::fread(dihedrals,
                             verbose=FALSE,
                             showProgress=FALSE)
    resnos <- storedResnos

  } else if (!all(resnos %in% storedResnos)) {
    stop(paste("read.dihedrals: File", dihedrals,
               "does not contain all of the requested residues."))
  } else {
    # Compute the columns corresponding to the given residue numbers.
    cols <- do.call("c", lapply(resnos,
                                function(i){c(2*(which(i==storedResnos))-1,
                                              2*(which(i==storedResnos)))}))
    dih <- data.table::fread(dihedrals,
                             select=cols,
                             verbose=FALSE,
                             showProgress=FALSE)
  }
  colnames(dih) <- paste(c("phi", "psi"), rep(resnos, each=2), sep="")
  return(dih)
}

#' Read dihedrals information.
#'
#' Reads a .dih.info file as generated by \code{\link{write.dihedrals.info}}.
#'
#' @param dihedralsInfo Character, name of the .dih.info file.
#' @return named list with elements \code{ref}, \code{traj}, \code{nRes},
#'   \code{skippedResnos}
read.dihedrals.info <- function(dihedralsInfo) {

  lines <- scan(dihedralsInfo, what=character(), sep="\n", quiet=TRUE)

  ref <- strsplit(lines[1], " ")[[1]][-1]
  traj <- strsplit(lines[2], " ")[[1]][-1]
  nRes <- as.numeric(strsplit(lines[3], " ")[[1]][-1])
  skippedResnos <- as.numeric(strsplit(lines[4], " ")[[1]][-1])

  return(list(ref=ref, traj=traj, nRes=nRes, skippedResnos = skippedResnos))
}

#' Write dihedrals infomation.
#'
#' Writes a .dih.info file with the following format (all fields are separated
#' by a single space):
#' \preformatted{
#' reference <normalized path to .pdb file>
#' trajectory <normalized path to .xtc file>r
#' nResiduals <integer>
#' skippedResiduals <space separated integers increasingly ordered>
#' }
#'
#' @param ref Character, name of the PDB file describing the reference structure.
#' @param traj Character, name of the XTC file describing the trajectory.
#' @param nRes Numeric, largest residue index
#' @param skipCA Numeric vector, C\eqn{_\alpha} indices to be skipped in
#'   increasing order.
#' @param fname Character, filename that should end in .dih.inf \cr
#'   If \code{NULL} (default) the file is named <traj>.dih.info
#' @export
write.dihedrals.info <- function(ref, traj, nRes, skipCA, fname=NULL) {
  if (is.null(fname)) {
    fname_dihedrals_info <- paste(traj, ".dih.info", sep="")
  }
  write(paste(paste("reference",  ref),
              paste("trajectory", traj),
              paste("nResiduals", nRes),
              paste("skippedResiduals", paste(skipCA, collapse=" ")),
              sep = "\n"),
        file = fname_dihedrals_info)
}

#' Read cumulative fluctuations.
#'
#' Read cumulative fluctuations for the given PCA procedure.
#'
#' @param pca Selected PCA-procedure
#' @param corr Use correlation-based PCA
#' @return cumulative fluctuations
#' @export
read.cumFlucts <- function(pca, corr=FALSE) {

  if (corr) {
    vals <- data.table::fread(pca$valn)
  } else {
    vals <- data.table::fread(pca$val)
  }
  vals <- vals$V1

  cumsum(vals/max(vals))
}



